<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="In November 2023, the WasmGC1 became the default in Chrome2 and Firefox3. It is a really exciting change, and is a good sign that the WasmGC is coming to standarization. Some GC programming languages such as OCaml4, Kotlin5, Dart6, and Java7 have an implementation that compiles to Wasm with WasmGC support.
We can learn the high-level view of WasmGC in the blog post by V8: A new way to bring garbage collected programming languages efficiently to WebAssembly · V8"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="New types and instructions to be introduced in WasmGC"><meta property="og:description" content="In November 2023, the WasmGC1 became the default in Chrome2 and Firefox3. It is a really exciting change, and is a good sign that the WasmGC is coming to standarization. Some GC programming languages such as OCaml4, Kotlin5, Dart6, and Java7 have an implementation that compiles to Wasm with WasmGC support.
We can learn the high-level view of WasmGC in the blog post by V8: A new way to bring garbage collected programming languages efficiently to WebAssembly · V8"><meta property="og:type" content="article"><meta property="og:url" content="https://tanishiking.github.io/posts/wasm-gc/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-01T00:00:00+00:00"><meta property="article:modified_time" content="2024-01-01T00:00:00+00:00"><title>New types and instructions to be introduced in WasmGC | Rikito Taniguchi</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=stylesheet href=/book.min.5e94238746c33238fee6ef6317d0a5b3b8c41850ca35e068bc8af844a7a228ab.css integrity="sha256-XpQjh0bDMjj+5u9jF9Cls7jEGFDKNeBovIr4RKeiKKs=" crossorigin=anonymous></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Rikito Taniguchi</span></a></h2><img src="https://gravatar.com/avatar/e4c6d83c22681eb9483c4ed20d3bb828b572ebe6ef7514b37a83769b7cf7ef48?s=150"><p>Scala Compiler Engineer @ <a href=https://virtuslab.com/>VirtusLab</a></p></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>New types and instructions to be introduced in WasmGC</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><h2><a href=/posts>All posts</a></h2><hr><nav id=TableOfContents><ul><li><a href=#reference-types>Reference Types</a></li><li><a href=#heap-types>Heap Types</a><ul><li><a href=#structures>structures</a></li><li><a href=#arrays>arrays</a></li><li><a href=#recursive-types>Recursive types</a></li><li><a href=#unboxed-scalars>Unboxed Scalars</a></li><li><a href=#external-types>External Types</a></li></ul></li><li><a href=#type-hierarchy>Type Hierarchy</a></li><li><a href=#subtypes>Subtypes</a></li><li><a href=#abbreviations>Abbreviations</a></li><li><a href=#new-instructions>New instructions</a><ul><li><a href=#i31>i31.*</a></li><li><a href=#array-and-struct>array.* and struct.*</a></li><li><a href=#br_on_>br_on_*</a></li><li><a href=#ref>ref.*</a></li><li><a href=#extern>extern.*</a></li></ul></li><li><a href=#convert-between-wasm-and-wat-of-wasmgc--waml>Convert between wasm and wat of wasmgc / waml</a><ul><li><a href=#dockerfile>Dockerfile</a></li><li><a href=#wasm-reference-interpreter>wasm reference interpreter</a></li><li><a href=#waml>waml</a></li></ul></li><li><a href=#references>References</a></li></ul></nav></aside></header><article class="markdown book-post"><h1><a href=/posts/wasm-gc/>New types and instructions to be introduced in WasmGC</a></h1><h5>January 1, 2024</h5><div><a href=/tags/webassembly/>webassembly</a></div><p>In November 2023, the WasmGC<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> became the default in Chrome<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> and Firefox<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>. It is a really exciting change, and is a good sign that the WasmGC is coming to standarization.
Some GC programming languages such as OCaml<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>, Kotlin<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>, Dart<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>, and Java<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup> have an implementation that compiles to Wasm with WasmGC support.</p><p>We can learn the high-level view of WasmGC in the blog post by V8: <a href=https://v8.dev/blog/wasm-gc-porting>A new way to bring garbage collected programming languages efficiently to WebAssembly · V8</a></p><p>However, what exactly is WasmGC? What compilers need to do to support it?</p><p>From compilers&rsquo; point of view, WasmGC is basically an extension of Wasm language with new heap types, and new instruction to allocate and control those heap objects. If compilers generate Wasm code with those new WasmGC types and instruction (WasmGC primitives), then the Wasm code can be executed with GC, in the runtime that supports WasmGC.</p><p>In this article, we will explore the new types and instructions that will be introduced by WasmGC.</p><h2 id=reference-types>Reference Types
<a class=anchor href=#reference-types>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(<span style=color:#66d9ef>type</span> $A (struct)) <span style=color:#75715e>;; index = 0</span>
</span></span><span style=display:flex><span>(func $f1 (param (ref <span style=color:#a6e22e>null</span> $A))) <span style=color:#75715e>;; func f1(a *A) { ... }</span>
</span></span><span style=display:flex><span>(func $f2 (result (ref <span style=color:#ae81ff>0</span>))) <span style=color:#75715e>;; func f2() *A { ... }</span>
</span></span></code></pre></div><p><code>(ref null &lt;heap-type>)</code> means that the reference can be a null reference.</p><h2 id=heap-types>Heap Types
<a class=anchor href=#heap-types>#</a></h2><p>The wasm gc proposal adds heap to wasm engine in addition to stack and linear memory (or perhaps it is more accurate to say, a heap is required for the wasmgc execution engine).</p><blockquote><p>&ldquo;The introduction of managed data adds new forms of types that describe the layout of memory blocks on the heap&rdquo;
<a href=https://github.com/WebAssembly/gc/blob/main/proposals/gc/Overview.md#types>https://github.com/WebAssembly/gc/blob/main/proposals/gc/Overview.md#types</a></p></blockquote><h3 id=structures>structures
<a class=anchor href=#structures>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(<span style=color:#66d9ef>type</span> $time (struct (field i32) (field f64)))
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>type</span> $point (struct (field $x f64) (field $y f64) (field $z f64)))
</span></span></code></pre></div><ul><li><code>structtype ::= struct &lt;fieldtype>*</code></li><li><code>fieldtype ::= &lt;mutability> &lt;storagetype></code></li></ul><h3 id=arrays>arrays
<a class=anchor href=#arrays>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(<span style=color:#66d9ef>type</span> $vector (<span style=color:#a6e22e>array</span> (mut f64)))
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>type</span> $matrix (<span style=color:#a6e22e>array</span> (mut (ref $vector))))
</span></span></code></pre></div><p>Basically the same as structures. <code>arraytype ::= array &lt;fieldtype></code></p><h3 id=recursive-types>Recursive types
<a class=anchor href=#recursive-types>#</a></h3><p><code>rec</code> allows types that are mutually recursive to be defined. And a single type definition can also be recursive.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(rec
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>type</span> $A (struct (field $b (ref <span style=color:#a6e22e>null</span> $B))))
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>type</span> B$ (struct (field $a (ref <span style=color:#a6e22e>null</span> $A))))
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>type</span> $C (struct field $f i32) (field $c (ref <span style=color:#a6e22e>null</span> $C)))
</span></span></code></pre></div><h3 id=unboxed-scalars>Unboxed Scalars
<a class=anchor href=#unboxed-scalars>#</a></h3><p><code>i31ref</code> <a href=https://github.com/WebAssembly/gc/blob/main/proposals/gc/Overview.md#unboxed-scalars>https://github.com/WebAssembly/gc/blob/main/proposals/gc/Overview.md#unboxed-scalars</a></p><p>In order to treat numeric types such as <code>i32</code> in the same way as other heap types (structures and arrays), those types need to be boxed (which can be a costly operation if the value is frequently accessed).
Unboxed scalars allow wasm engine to avoid the boxing cost for frequently accessed primitive types.</p><p>Instead of boxing a <code>i32</code>, 31 bits are used to store the actual value and the remaining 1 bit is used to flag indicate that &ldquo;it is not a pointer, and the remaining 31 bits contain the value, so you can use it as it is&rdquo;. This allows 31-bit numeric types to be used in the same way as other reference types, without the cost of boxing.</p><p>(IIUC)</p><ul><li><a href=https://stackoverflow.com/questions/77468063/why-do-we-need-the-type-of-i31-in-wasmgc-proposal>webassembly - Why do we need the type of i31 in WasmGC proposal? - Stack Overflow</a>o</li><li><a href=https://rust-hosted-langs.github.io/book/chapter-interp-tagged-ptrs.html>Tagged pointers and object headers - Writing Interpreters in Rust: a Guide</a></li></ul><h3 id=external-types>External Types
<a class=anchor href=#external-types>#</a></h3><p>References/functions in the host can be treated as type <code>externref/funcref</code> in WASM. The following hello function can accept parameters of type <code>externref</code>, e.g. the host JS code can give a reference in JS to hello as an argument.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(func (<span style=color:#a6e22e>export</span> <span style=color:#e6db74>&#34;hello&#34;</span>) (param externref) <span style=color:#f92672>...</span>)
</span></span></code></pre></div><p>Refer <a href=https://bytecodealliance.org/articles/reference-types-in-wasmtime>Bytecode Alliance — WebAssembly Reference Types in Wasmtime</a> for more details.</p><p>Also, <a href=https://github.com/WebAssembly/proposal-type-imports/blob/main/proposals/type-imports/Overview.md>type imports proposal</a> can be interesting.</p><h2 id=type-hierarchy>Type Hierarchy
<a class=anchor href=#type-hierarchy>#</a></h2><p>The heap types that represent the data layouts placed in a heap can be classified into three types</p><ul><li>Internal (values in Wasm representation)</li><li>External (values in a host-specific representation)</li><li>Functions</li></ul><p>And each has a type hierarchy</p><ul><li><code>eq</code> is the common super type of all reference types that can be compared by <code>ref.eq</code></li><li><code>any</code> is the top type of internal types</li><li><code>none</code> is the bottom type of internal types</li><li><code>noextern</code> is the bottom type of external types</li><li><code>nofunc</code> is the bottom type of function types</li><li><code>struct</code> is the super type of all struct types</li><li><code>array</code> is super type of all array types</li><li><code>i31</code> is a supertype of unboxed scalars</li></ul><p>in summary</p><p><img src=/images/type-hierarchy.png alt></p><h2 id=subtypes>Subtypes
<a class=anchor href=#subtypes>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(<span style=color:#66d9ef>type</span> $A (struct)) <span style=color:#75715e>;; Abbreviation of `(type $A (sub (struct)))`</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>type</span> $A (sub (struct))) <span style=color:#75715e>;; class A {}</span>
</span></span><span style=display:flex><span> <span style=color:#75715e>;; Define a type B with a field of i32, that is a subtype of A</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>type</span> $B (sub $A (struct (field i32))))
</span></span><span style=display:flex><span> <span style=color:#75715e>;; Define a type C with fields of i32 and i64, that is a subtype of B</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>type</span> $C (sub final $B (struct (field i32 i64))))
</span></span></code></pre></div><blockquote><p>the preexisting syntax with no sub clause is redefined to be a shorthand for a sub clause with empty typeidx list</p></blockquote><h2 id=abbreviations>Abbreviations
<a class=anchor href=#abbreviations>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>funcref == (ref <span style=color:#a6e22e>null</span> func)
</span></span><span style=display:flex><span>externref == (ref <span style=color:#a6e22e>null</span> extern)
</span></span><span style=display:flex><span>anyref == (ref <span style=color:#a6e22e>null</span> any)
</span></span><span style=display:flex><span>nullref == (ref <span style=color:#a6e22e>null</span> none)
</span></span><span style=display:flex><span>nullexternref == (ref <span style=color:#a6e22e>null</span> noextern)
</span></span><span style=display:flex><span>nullfuncref == (ref <span style=color:#a6e22e>null</span> nofunc)
</span></span><span style=display:flex><span>eqref == (ref <span style=color:#a6e22e>null</span> <span style=color:#a6e22e>eq</span>)
</span></span><span style=display:flex><span>structref == (ref <span style=color:#a6e22e>null</span> struct)
</span></span><span style=display:flex><span>arrayref == (ref <span style=color:#a6e22e>null</span> <span style=color:#a6e22e>array</span>)
</span></span><span style=display:flex><span>i31ref == (ref <span style=color:#a6e22e>null</span> i31)
</span></span></code></pre></div><h2 id=new-instructions>New instructions
<a class=anchor href=#new-instructions>#</a></h2><h3 id=i31>i31.*
<a class=anchor href=#i31>#</a></h3><p><code>i31.get_u</code>, <code>i31.get_s</code> and so on (get_u/s are with or without sign extension)</p><h3 id=array-and-struct>array.* and struct.*
<a class=anchor href=#array-and-struct>#</a></h3><ul><li><code>array.new</code>, <code>struct.new</code></li><li><code>array.get/set</code>, <code>struct.get/set</code></li><li><code>array.len/fill/copy</code></li><li>and more</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lisp data-lang=lisp><span style=display:flex><span>(<span style=color:#66d9ef>type</span> $vector (<span style=color:#a6e22e>array</span> (mut f64)))
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>type</span> $tup (struct i64 i64 i32))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>;; array.new &lt;type&gt; &lt;values&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;; struct.new &lt;type&gt; &lt;values&gt;</span>
</span></span><span style=display:flex><span>(local.set $v (array.new $vector (f64.const <span style=color:#ae81ff>1</span>) (i32.const <span style=color:#ae81ff>3</span>)))
</span></span><span style=display:flex><span>(local.set $t (struct.new $tup (i64.const <span style=color:#ae81ff>1</span>) (i64.const <span style=color:#ae81ff>2</span>) (i64.const <span style=color:#ae81ff>1</span>)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>;; array.get &lt;type&gt; &lt;arrayref&gt; &lt;index&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;; struct.get &lt;type&gt; &lt;index&gt; &lt;structref&gt;</span>
</span></span><span style=display:flex><span>(array.get $vector (local.get $v) (i32.const <span style=color:#ae81ff>1</span>)) <span style=color:#75715e>;; Get the 1st element of $v(0-index)</span>
</span></span><span style=display:flex><span>(struct.get $tup <span style=color:#ae81ff>1</span> (local.get $t)) <span style=color:#75715e>;; $t の1番目の要素を取得</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>;; array.set &lt;type&gt; &lt;arrayref&gt; &lt;index&gt; &lt;value&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;; struct.set &lt;type&gt; &lt;index&gt; &lt;sturctref&gt; &lt;value&gt;</span>
</span></span><span style=display:flex><span>(array.set $vector (local.get $v) (i32.const <span style=color:#ae81ff>2</span>) (i32.const <span style=color:#ae81ff>5</span>)) <span style=color:#75715e>;; Set 5 to the 2nd element of $v</span>
</span></span><span style=display:flex><span>(struct.set $tup <span style=color:#ae81ff>1</span> (local.get $t) (i64.const <span style=color:#ae81ff>100</span>)) <span style=color:#75715e>;; Set 100 to the 1st field of $t</span>
</span></span></code></pre></div><h3 id=br_on_>br_on_*
<a class=anchor href=#br_on_>#</a></h3><p>Branching based on the value of the reference type</p><ul><li><code>br_on_cast</code><ul><li><code>(br_on_cast $label &lt;value> &lt;rtt>)</code></li><li>If the runtime type of the second argument <code>value</code> can be cast to the <code>rtt</code>, push the value of type <code>rtt</code> to the stach and branch to <code>$label</code>.</li></ul></li><li><code>br_on_cast_fail</code><ul><li><code>(br_on_cast_fail $label &lt;value> &lt;rtt>)</code></li><li>If the <code>value</code> cannot be cast to <code>rtt</code>, branch to <code>$label</code> with <code>value</code> on the stack.</li></ul></li><li><code>br_on_null $l &lt;value></code><ul><li><code>(br_on_null $l (local.get $r))</code></li><li>If <code>$r</code> is a null reference, branch to <code>$l</code></li></ul></li><li><code>br_on_non_null $l</code></li></ul><h3 id=ref>ref.*
<a class=anchor href=#ref>#</a></h3><p>casting and testing values of reference types</p><ul><li><code>ref.null ht</code> - create a null reference of type <code>ht</code> <code>(e.g. ref.null eq)</code></li><li><code>ref.i31 $x</code> - create <code>i31ref</code> from <code>$x: i32</code></li><li><code>ref.test &lt;ref ht> &lt;runtime-type></code><ul><li>Checks if the first argument reference can be cast to the second argument runtime-type. 1 if it can, 0 if it cannot.</li></ul></li><li><code>ref.cast &lt;ref ht> &lt;runtime-type></code><ul><li>Casts the first argument reference to the second argument runtime-type.</li><li>If it cannot be cast, trap</li></ul></li><li><code>ref.is_null &lt;ref ht></code><ul><li>1 if the given reference is null, 0 otherwise</li></ul></li><li><code>ref.as_non_null &lt;ref null ht></code> - make a nullable reference non-nullable? Not sure.</li><li><code>ref.eq &lt;ref ht> &lt;ref ht></code><ul><li>Receives two <code>eqref</code> operands and performs an identity check on the values of the two references. (I haven&rsquo;t found any mention of specific identity checks).</li></ul></li><li><code>ref.func</code> - create a function reference of the given function</li></ul><h3 id=extern>extern.*
<a class=anchor href=#extern>#</a></h3><p>&ldquo;converts an external value into the internal representation&rdquo;</p><ul><li><code>extern.convert_any</code></li><li><code>any.convert_extern</code></li></ul><h2 id=convert-between-wasm-and-wat-of-wasmgc--waml>Convert between wasm and wat of wasmgc / waml
<a class=anchor href=#convert-between-wasm-and-wat-of-wasmgc--waml>#</a></h2><h3 id=dockerfile>Dockerfile
<a class=anchor href=#dockerfile>#</a></h3><p><a href=https://github.com/tanishiking/waml-docker>tanishiking/waml-docker: Dockerfile for build and running WAML</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ docker build . -t waml
</span></span><span style=display:flex><span>$ docker run -it waml waml -x -c
</span></span><span style=display:flex><span>waml 0.2 interpreter
</span></span><span style=display:flex><span>&gt; val f x <span style=color:#f92672>=</span> x + 7;  f 5;
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># compile waml to wasm</span>
</span></span><span style=display:flex><span>$ docker run -i -v <span style=color:#e6db74>&#34;</span>$PWD<span style=color:#e6db74>&#34;</span>:/data waml waml -c /data/test.waml
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># compile waml to wat</span>
</span></span><span style=display:flex><span>$ docker run -i -v <span style=color:#e6db74>&#34;</span>$PWD<span style=color:#e6db74>&#34;</span>:/data waml waml -c -x /data/test.waml
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># convert wat to wasm</span>
</span></span><span style=display:flex><span>$ docker run -i -v <span style=color:#e6db74>&#34;</span>$PWD<span style=color:#e6db74>&#34;</span>:/data waml wasm -d /data/test.wat -o /data/test.wasm
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># interpret wasm</span>
</span></span><span style=display:flex><span>$ docker run -i -v <span style=color:#e6db74>&#34;</span>$PWD<span style=color:#e6db74>&#34;</span>:/data waml wasm /data/test.wasm
</span></span></code></pre></div><h3 id=wasm-reference-interpreter>wasm reference interpreter
<a class=anchor href=#wasm-reference-interpreter>#</a></h3><p>There is a wasm reference interpreter in <a href=https://github.com/WebAssembly/gc/tree/main/interpreter>the /interpreter directory of the WebAssembly spec</a>, and with <code>WebAssembly/gc</code> you can use a reference interpreter that supports wasm gc.</p><p>V8 can also run wasmgc by default, so you can run it from Deno, Node or other browsers.</p><h3 id=waml>waml
<a class=anchor href=#waml>#</a></h3><blockquote><p>An experimental functional language and implementation for exploring and evaluating the Wasm GC proposal.</p></blockquote><p>There is also a mini ML language that can be compiled into wasmgc. It is also a good way to learn what kind of code should be converted into what kind of wasmgc code.</p><p>Also, read the kotlin/wasm generated wasmgc code <a href=https://tanishiking.github.io/posts/kotlin-wasm-deep-dive/>Exploring WAT Files Generated from Kotlin/Wasm | Rikito Taniguchi</a></p><h2 id=references>References
<a class=anchor href=#references>#</a></h2><ul><li><a href=https://github.com/WebAssembly/gc/blob/main/proposals/gc/Overview.md>gc/proposals/gc/Overview.md at main · WebAssembly/gc</a></li><li><a href=https://github.com/WebAssembly/gc/blob/main/proposals/gc/MVP.md>gc/proposals/gc/MVP.md at main · WebAssembly/gc</a></li><li><a href=https://v8.dev/blog/wasm-gc-porting>A new way to bring garbage collected programming languages efficiently to WebAssembly · V8</a></li><li><a href="https://www.youtube.com/watch?v=ndJP-vmZFYk">Wasm GC: What Exactly Is It (and Why I Should Care) - Ivan Mikushin, VMware - YouTube</a></li><li><a href=https://stackoverflow.com/questions/77468063/why-do-we-need-the-type-of-i31-in-wasmgc-proposal>webassembly - Why do we need the type of i31 in WasmGC proposal? - Stack Overflow</a></li><li><a href=https://bytecodealliance.org/articles/reference-types-in-wasmtime>Bytecode Alliance — WebAssembly Reference Types in Wasmtime</a></li></ul><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://github.com/WebAssembly/gc>https://github.com/WebAssembly/gc</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://developer.chrome.com/blog/wasmgc>https://developer.chrome.com/blog/wasmgc</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><a href=https://www.mozilla.org/en-US/firefox/120.0/releasenotes/>https://www.mozilla.org/en-US/firefox/120.0/releasenotes/</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><a href=https://github.com/ocaml-wasm/wasm_of_ocaml>https://github.com/ocaml-wasm/wasm_of_ocaml</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p><a href=https://kotlinlang.org/docs/wasm-overview.html>https://kotlinlang.org/docs/wasm-overview.html</a>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p><a href=https://github.com/dart-lang/sdk/blob/5510ef63a6dcd06423305e15e2014cf20ac94699/pkg/dart2wasm/README.md>https://github.com/dart-lang/sdk/blob/5510ef63a6dcd06423305e15e2014cf20ac94699/pkg/dart2wasm/README.md</a>&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p><a href=https://github.com/google/j2cl/blob/b3ff9e233cef3e67e495476da14f13250a56c5e9/docs/getting-started-j2wasm.md>https://github.com/google/j2cl/blob/b3ff9e233cef3e67e495476da14f13250a56c5e9/docs/getting-started-j2wasm.md</a>&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><h2><a href=/posts>All posts</a></h2><hr><nav id=TableOfContents><ul><li><a href=#reference-types>Reference Types</a></li><li><a href=#heap-types>Heap Types</a><ul><li><a href=#structures>structures</a></li><li><a href=#arrays>arrays</a></li><li><a href=#recursive-types>Recursive types</a></li><li><a href=#unboxed-scalars>Unboxed Scalars</a></li><li><a href=#external-types>External Types</a></li></ul></li><li><a href=#type-hierarchy>Type Hierarchy</a></li><li><a href=#subtypes>Subtypes</a></li><li><a href=#abbreviations>Abbreviations</a></li><li><a href=#new-instructions>New instructions</a><ul><li><a href=#i31>i31.*</a></li><li><a href=#array-and-struct>array.* and struct.*</a></li><li><a href=#br_on_>br_on_*</a></li><li><a href=#ref>ref.*</a></li><li><a href=#extern>extern.*</a></li></ul></li><li><a href=#convert-between-wasm-and-wat-of-wasmgc--waml>Convert between wasm and wat of wasmgc / waml</a><ul><li><a href=#dockerfile>Dockerfile</a></li><li><a href=#wasm-reference-interpreter>wasm reference interpreter</a></li><li><a href=#waml>waml</a></li></ul></li><li><a href=#references>References</a></li></ul></nav></div></aside></main></body></html>