<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="In this article, I&rsquo;m examining the generated WAT (WebAssembly Text) files from Kotlin/Wasm and investigating how high-level constructs in Kotlin map to WasmGC.
Generating WAT from Kotlin/Wasm # https://github.com/Kotlin/kotlin-wasm-examples
I&rsquo;ll work with the kotlin-wasm-example/nodejs-example and inspecting the output. The version at the time of writing is Kotlin 1.9.20.
To generate WAT files, I&rsquo;m passing the -Xwasm-generate-wat flag to the compiler1.
❯ git diff nodejs-example/build.gradle.kts diff --git a/nodejs-example/build.gradle.kts b/nodejs-example/build.gradle.kts index 6b48777..fa21751 100644 --- a/nodejs-example/build."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="Exploring WAT Files Generated from Kotlin/Wasm"><meta property="og:description" content="In this article, I&rsquo;m examining the generated WAT (WebAssembly Text) files from Kotlin/Wasm and investigating how high-level constructs in Kotlin map to WasmGC.
Generating WAT from Kotlin/Wasm # https://github.com/Kotlin/kotlin-wasm-examples
I&rsquo;ll work with the kotlin-wasm-example/nodejs-example and inspecting the output. The version at the time of writing is Kotlin 1.9.20.
To generate WAT files, I&rsquo;m passing the -Xwasm-generate-wat flag to the compiler1.
❯ git diff nodejs-example/build.gradle.kts diff --git a/nodejs-example/build.gradle.kts b/nodejs-example/build.gradle.kts index 6b48777..fa21751 100644 --- a/nodejs-example/build."><meta property="og:type" content="article"><meta property="og:url" content="https://tanishiking.github.io/posts/kotlin-wasm-deep-dive/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-21T00:00:00+00:00"><meta property="article:modified_time" content="2023-12-21T00:00:00+00:00"><title>Exploring WAT Files Generated from Kotlin/Wasm | Rikito Taniguchi</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=stylesheet href=/book.min.a8d552c443a716e28e13d742e238f88d1e96de5f5b417aa8f75f62416ab0eb80.css integrity="sha256-qNVSxEOnFuKOE9dC4jj4jR6W3l9bQXqo919iQWqw64A=" crossorigin=anonymous></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Rikito Taniguchi</span></a></h2><img src="https://gravatar.com/avatar/e4c6d83c22681eb9483c4ed20d3bb828b572ebe6ef7514b37a83769b7cf7ef48?s=150"><p>Scala Compiler Engineer @ <a href=https://virtuslab.com/>VirtusLab</a></p><ul><li><a href=/posts/>Blog</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Exploring WAT Files Generated from Kotlin/Wasm</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#generating-wat-from-kotlinwasm>Generating WAT from Kotlin/Wasm</a></li><li><a href=#examining-the-wat-generated-by-kotlinwasm>Examining the WAT Generated by Kotlin/Wasm</a><ul><li><a href=#direct-function-calling>Direct Function Calling</a></li><li><a href=#data-class>(data) class</a></li><li><a href=#virtual-call>virtual call</a></li><li><a href=#interface-dispatch>interface dispatch</a></li><li><a href=#varargs>varargs</a></li><li><a href=#generic-function>generic function</a></li><li><a href=#generic-class>generic class</a></li><li><a href=#enum-and-pattern-match>enum and pattern match</a></li></ul></li><li><a href=#conculusion>Conculusion</a></li><li><a href=#references>References</a></li></ul></nav></aside></header><article class="markdown book-post"><h1><a href=/posts/kotlin-wasm-deep-dive/>Exploring WAT Files Generated from Kotlin/Wasm</a></h1><h5>December 21, 2023</h5><div><a href=/tags/webassembly/>webassembly</a>,
<a href=/tags/kotlin/>kotlin</a></div><p>In this article, I&rsquo;m examining the generated WAT (WebAssembly Text) files from <code>Kotlin/Wasm</code> and investigating how high-level constructs in Kotlin map to WasmGC.</p><h2 id=generating-wat-from-kotlinwasm>Generating WAT from Kotlin/Wasm
<a class=anchor href=#generating-wat-from-kotlinwasm>#</a></h2><p><a href=https://github.com/Kotlin/kotlin-wasm-examples>https://github.com/Kotlin/kotlin-wasm-examples</a></p><p>I&rsquo;ll work with the <code>kotlin-wasm-example/nodejs-example</code> and inspecting the output. The version at the time of writing is Kotlin 1.9.20.</p><p>To generate WAT files, I&rsquo;m passing the <code>-Xwasm-generate-wat</code> flag to the compiler<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>❯ git diff nodejs-example/build.gradle.kts
</span></span><span style=display:flex><span>diff --git a/nodejs-example/build.gradle.kts b/nodejs-example/build.gradle.kts
</span></span><span style=display:flex><span>index 6b48777..fa21751 100644
</span></span><span style=display:flex><span><span style=color:#f92672>--- a/nodejs-example/build.gradle.kts
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+++ b/nodejs-example/build.gradle.kts
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -26,3 +26,9 @@ rootProject.the&lt;NodeJsRootExtension&gt;().apply {
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> tasks.withType&lt;org.jetbrains.kotlin.gradle.targets.js.npm.tasks.KotlinNpmInstallTask&gt;().configureEach {
</span></span><span style=display:flex><span>     args.add(&#34;--ignore-engines&#34;)
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span><span style=color:#a6e22e>+
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+tasks.withType&lt;org.jetbrains.kotlin.gradle.tasks.Kotlin2JsCompile&gt;().configureEach {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    kotlinOptions.freeCompilerArgs += listOf(
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+        &#34;-Xwasm-generate-wat&#34;,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+    )
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+}
</span></span></span></code></pre></div><p>I&rsquo;ve edited <code>nodejs-example/src/wasmJsMain/kotlin/Main.kt</code> as follows for simplifying the build result (since the main function has a lot of glue code, making it hard to read).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    box()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>box</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ cd nodejs-example
</span></span><span style=display:flex><span>$ ./gradlew build
</span></span><span style=display:flex><span>$ cat ./build/js/packages/kotlin-wasm-nodejs-example-wasm-js/kotlin/kotlin-wasm-nodejs-example-wasm-js.wat
</span></span></code></pre></div><h2 id=examining-the-wat-generated-by-kotlinwasm>Examining the WAT Generated by Kotlin/Wasm
<a class=anchor href=#examining-the-wat-generated-by-kotlinwasm>#</a></h2><p>The generated WAT file is around 3000 lines long. I&rsquo;ll extract relevant code fragments for clarity.</p><h3 id=direct-function-calling>Direct Function Calling
<a class=anchor href=#direct-function-calling>#</a></h3><p>Let&rsquo;s start with the simplest example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>foo</span>(a: Int, b: Int) = a + b
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>box</span>() {
</span></span><span style=display:flex><span>    foo(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code class=language-wasm data-lang=wasm>(type $____type_3 (func (param)))
(func $box___fun_62 (type $____type_3)
    i32.const 1
    i32.const 1
    call $foo___fun_61
    drop)

(type $____type_0 (func (param i32 i32) (result i32)))
(func $foo___fun_61 (type $____type_0)
    (param $0_a i32)
    (param $1_b i32) (result i32)
    local.get $0_a  ;; type: kotlin.Int
    local.get $1_b  ;; type: kotlin.Int
    i32.add
    return)
</code></pre><p>Ok, that&rsquo;s easy.</p><h3 id=data-class>(data) class
<a class=anchor href=#data-class>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Foo</span>(<span style=color:#66d9ef>val</span> bar: Int) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> baz: Int = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>box</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> foo = Foo(<span style=color:#ae81ff>100</span>)
</span></span><span style=display:flex><span>    foo.baz = <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>First, the <code>Person</code> class is represented with a struct.</p><pre tabindex=0><code class=language-wasm data-lang=wasm>(type $Foo___type_36 (sub $kotlin.Any___type_13 (struct
  (field (ref $Foo.vtable___type_26))
  (field (ref null struct))
  (field (mut i32))
  (field (mut i32))
  (field (mut i32)) ;; bar
  (field (mut i32))))) ;; baz
</code></pre><p><code>$Foo___type_36</code> is a subtype of <code>kotlin.Any___type_13</code>, and <code>Any</code> has the following data structure:</p><pre tabindex=0><code class=language-wasm data-lang=wasm>(type $kotlin.Any___type_13 (struct
    (field (ref $kotlin.Any.vtable___type_12)) ;; vtable
    (field (ref null struct)) ;; itable
    (field (mut i32)) ;; typeInfo
    (field (mut i32)))) ;; hashCode
</code></pre><p>The presentation at WASM/IO 2023 has a great explanation on the data representation: <a href=https://seb.deleuze.fr/introducing-kotlin-wasm/>Introducing Kotlin/Wasm · seb.deleuze.fr</a></p><p><code>vtable</code> and <code>itable</code> are well-known data structures used for dynamic dispatch<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>. I&rsquo;ll provide more detailed information in the later section on virtual calls.</p><p>Next, let&rsquo;s look at the implementation of <code>box</code> and how <code>Foo</code> is initialized.</p><pre tabindex=0><code class=language-wasm data-lang=wasm>(func $box___fun_62 (type $____type_3)
    (local $0_foo (ref null $Foo___type_36))
    ref.null none
    i32.const 100
    call $Foo.&lt;init&gt;___fun_61
    local.tee $0_foo  ;; type: &lt;root&gt;.Foo
    i32.const 10
    struct.set $Foo___type_36 5  ;; name: baz, type: kotlin.Int)
</code></pre><ul><li><code>val foo = Foo(100)</code><ul><li><code>ref.null none</code> (null reference with bottom type as RTT) and <code>i32.const 100</code> as operand <code>call $Foo.&lt;init>___fun_61</code></li></ul></li><li><code>foo.baz = 10</code><ul><li>with reference to an instance of <code>Foo</code> (<code>$0_foo</code>) and <code>i32.const 10</code> as operand, <code>struct.set $foo___type_36 5</code> (set <code>i32.const 10</code> to the fifth field (<code>baz</code>) in <code>$0_foo</code>)</li></ul></li></ul><p>Ok, then, what does <code>$Foo.&lt;init>___fun_61</code> do?</p><pre tabindex=0><code class=language-wasm data-lang=wasm>(func $Foo.&lt;init&gt;___fun_61 (type $____type_88)
    (param $0_&lt;this&gt; (ref null $Foo___type_36))
    (param $1_bar i32) (result (ref null $Foo___type_36))
    
    ;; Object creation prefix
    local.get $0_&lt;this&gt;
    ref.is_null
    if
        
        ;; Any parameters
        global.get $Foo.vtable___g_24
        ref.null struct
        i32.const 452
        i32.const 0
        
        i32.const 0
        i32.const 0
        struct.new $Foo___type_36
        local.set $0_&lt;this&gt;
    end
    
    local.get $0_&lt;this&gt;  ;; type: &lt;root&gt;.Foo
    local.get $1_bar  ;; type: kotlin.Int
    struct.set $Foo___type_36 4  ;; name: bar, type: kotlin.Int
    local.get $0_&lt;this&gt;  ;; type: &lt;root&gt;.Foo
    i32.const 0
    struct.set $Foo___type_36 5  ;; name: baz, type: kotlin.Int
    local.get $0_&lt;this&gt;
    return)
</code></pre><ul><li>If <code>$0_&lt;this></code> received as an argument is <code>null</code>, then<ul><li>Initialises vtable, itable, typeinfo and hashcode</li><li><code>Foo.vtable</code> is global</li></ul></li><li>bar and baz are given initial values, and a pointer <code>$0_&lt;this></code> to the Foo is returned</li></ul><p>How vtable and itable are created and used is described in the next section.</p><h3 id=virtual-call>virtual call
<a class=anchor href=#virtual-call>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>open</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Base</span>(p: Int) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>open</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>foo</span>() { <span style=color:#ae81ff>1</span> }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Derived</span>(p: Int) : Base(p) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>foo</span>() { <span style=color:#ae81ff>2</span> }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>box</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> d = Derived(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    bar(d)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>bar</span>(f: Base) = f.foo()
</span></span></code></pre></div><p>Base type:</p><pre tabindex=0><code class=language-wasm data-lang=wasm>;; type definition
(type $Base___type_36 (sub $kotlin.Any___type_13 (struct
    (field (ref $Base.vtable___type_26)) (field (ref null struct)) (field (mut i32)) (field (mut i32)))))
(type $Base.vtable___type_26 (sub $kotlin.Any.vtable___type_12 (struct
    (field (ref null $____type_53)))))
(type $____type_53 (func (param (ref null $kotlin.Any___type_13)) (result i32)))

;; instance of vtable
(global $Base.vtable___g_24 (ref $Base.vtable___type_26)
    ref.func $Base.foo___fun_62
    struct.new $Base.vtable___type_26)
(func $Base.foo___fun_62 (type $____type_53)
    (param $0_&lt;this&gt; (ref null $kotlin.Any___type_13)) (result i32)
    i32.const 1
    return)
</code></pre><ul><li><code>$Base___type_36</code> has the usual vtable, itable, typeinfo, hashCode</li><li>vtable contains a function reference to <code>Base.foo</code>.<ul><li>(it&rsquo;s not a <code>data class</code>, so there&rsquo;s no <code>hashCode</code> or <code>equals</code> definitions or anything like that).</li></ul></li></ul><p>Derived:</p><pre tabindex=0><code class=language-wasm data-lang=wasm>;; type definition
;; Same as Base___type_36 except super class is Base___type_36 and vtable is Derived.vtable
(type $Derived___type_42 (sub $Base___type_36 (struct
    (field (ref $Derived.vtable___type_39)) (field (ref null struct)) (field (mut i32)) (field (mut i32)))))
(type $Derived.vtable___type_39 (sub $Base.vtable___type_26 (struct
    (field (ref null $____type_53)))))
(type $____type_53 (func (param (ref null $kotlin.Any___type_13)) (result i32)))

;; vtable instance
(global $Derived.vtable___g_25 (ref $Derived.vtable___type_39)
    ref.func $Derived.foo___fun_64
    struct.new $Derived.vtable___type_39)
(func $Derived.foo___fun_64 (type $____type_53)
    (param $0_&lt;this&gt; (ref null $kotlin.Any___type_13)) (result i32)
    i32.const 2
    return)
</code></pre><p>Since <code>foo</code> is overridden, a function reference to <code>Derived.foo</code> is registered in the <code>Derived</code> vtable.</p><p>The <code>box</code> function looks like this.</p><pre tabindex=0><code class=language-wasm data-lang=wasm>(func $box___fun_65 (type $____type_3)
    (local $0_d (ref null $Derived___type_42))
    ref.null none
    i32.const 1
    call $Derived.&lt;init&gt;___fun_63
    local.tee $0_d  ;; type: &lt;root&gt;.Derived
    call $bar___fun_66)
</code></pre><ul><li><code>Drived.&lt;init></code> is the constructor as seen above.</li><li><code>$bar___fun_66</code> with Derived instance.</li></ul><pre tabindex=0><code class=language-wasm data-lang=wasm>(type $____type_92 (func (param (ref null $Base___type_36))))
(func $bar___fun_66 (type $____type_92)
    (param $0_f (ref null $Base___type_36)) (result i32)
    local.get $0_f  ;; type: &lt;root&gt;.Base
    local.get $0_f  ;; type: &lt;root&gt;.Base
    
    ;; virtual call: Base.foo
    struct.get $Base___type_36 0
    struct.get $Base.vtable___type_26 0
    call_ref (type $____type_53)
    
    return)
</code></pre><ul><li>First, push two references of type <code>Base___type_36</code> on the stack (in the code above we would pass a reference to an instance of <code>Derived</code>).<ul><li>One to get the function reference to <code>foo</code> from <code>Base.vtable</code>.</li><li>The other is as a receiver given to <code>Base.foo</code></li></ul></li><li>Get the vtable of <code>$0_f: (ref null $Base___type_36)</code> received as an argument in <code>struct.get $Base___type_36 0</code> (<code>Derived.vtable</code>)</li><li>Get function reference to <code>foo</code> from vtable with <code>struct.get $Base.vtable___type_26 0</code> (<code>Derived.foo</code>)</li><li>Function call with <code>call_ref</code>.</li></ul><h3 id=interface-dispatch>interface dispatch
<a class=anchor href=#interface-dispatch>#</a></h3><p>Kotlin (and Java&mldr;) has a single inheritance, but what if you are implementing multiple interfaces?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Base1</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>foo</span>(): Int
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Base2</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>bar</span>(): Int
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Base</span>: Base1, Base2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Derived</span>: Base {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>foo</span>(): Int = <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>bar</span>(): Int = <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>box</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> d = Derived()
</span></span><span style=display:flex><span>    baz(d)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>baz</span>(b: Base) = b.foo() + b.bar()
</span></span></code></pre></div><p>Starts with <code>box___fun</code></p><pre tabindex=0><code class=language-wasm data-lang=wasm>(func $box___fun_64 (type $____type_3)
    (local $0_d (ref null $Derived___type_40))
    ref.null none
    call $Derived.&lt;init&gt;___fun_61
    local.tee $0_d  ;; type: &lt;root&gt;.Derived
    call $baz___fun_65
    drop)
</code></pre><p>Just <code>call $Derived.&lt;init></code> and call <code>call $baz___fun_65</code>. We will look at <code>Derived.&lt;init></code>.</p><pre tabindex=0><code class=language-wasm data-lang=wasm>(type $Derived___type_40 (sub $kotlin.Any___type_16 (struct
    (field (ref $Derived.vtable___type_30))
    (field (ref null struct))
    (field (mut i32))
    (field (mut i32)))))

(func $Derived.&lt;init&gt;___fun_61 (type $____type_92)
    (param $0_&lt;this&gt; (ref null $Derived___type_40)) (result (ref null $Derived___type_40))
    
    ;; Object creation prefix
    local.get $0_&lt;this&gt;
    ref.is_null
    if
        
        ;; Any parameters
        global.get $Derived.vtable___g_24
        global.get $Derived.classITable___g_27
        i32.const 452
        i32.const 0
        
        struct.new $Derived___type_40
        local.set $0_&lt;this&gt;
    end
    
    local.get $0_&lt;this&gt;
    return)
</code></pre><p>We can see that <code>global.get Derived.classITable___g_27</code> sets the itable. What is this?</p><pre tabindex=0><code class=language-wasm data-lang=wasm>;; instance of itable
(global $Derived.classITable___g_27 (ref $classITable___type_20)
    ref.func $Derived.foo___fun_62
    struct.new $Base1.itable___type_13
    ref.func $Derived.bar___fun_63
    struct.new $Base2.itable___type_14
    struct.new $Base.itable___type_15
    struct.new $classITable___type_20)

;; type definition
(type $classITable___type_20 (struct
    (field (ref null $Base1.itable___type_13))
    (field (ref null $Base2.itable___type_14))
    (field (ref null $Base.itable___type_15))))
(type $Base1.itable___type_13 (struct (field (ref null $____type_55))))
(type $Base2.itable___type_14 (struct (field (ref null $____type_55))))
(type $Base.itable___type_15 (struct))
(type $____type_55 (func (param (ref null $kotlin.Any___type_16)) (result i32)))
</code></pre><ul><li>Each <code>Derived</code> itable has a reference to an itable of <code>Base1</code>, <code>Base2</code> or <code>Base</code>.</li><li>Each itable has a function reference of the function type declared in its interface.<ul><li>In <code>Base</code> there is no function declaration, so an empty struct</li></ul></li><li><code>global $Derived.classITable___g_27</code> registers a function reference to <code>Derived.foo</code> or <code>Derived.bar</code> in the itable.</li></ul><p>Then we&rsquo;ll look at the implementation on the caller side (<code>baz</code>).</p><pre tabindex=0><code class=language-wasm data-lang=wasm>(func $baz___fun_65 (type $____type_55)
    (param $0_b (ref null $kotlin.Any___type_16)) (result i32)
    local.get $0_b  ;; type: &lt;root&gt;.Base
    local.get $0_b  ;; type: &lt;root&gt;.Base
    
    ;; interface call: Base1.foo
    struct.get $kotlin.Any___type_16 1
    ref.cast $classITable___type_20
    struct.get $classITable___type_20 0
    struct.get $Base1.itable___type_13 0
    call_ref (type $____type_55)
    
    ;; ...
    
    i32.add
    return)
</code></pre><ul><li>First, two instances of <code>(param $0_b (ref null $kotlin.Any___type_16))</code> (actually instances of <code>Derived</code>) received as arguments are loaded onto the stack.<ul><li>Similar to the virtual call example, one to get the function reference from itable and one receiver</li></ul></li><li>Get the itable of <code>$0_b</code> with <code>struct.get $kotlin.Any___type_16 1</code>.</li><li>Cast this type to the <code>Derived</code> itable (<code>$classITable___type_20</code>)<ul><li>Why, unlike vtable, do we downcast the type of itable at runtime from <code>(ref null struct)</code>?</li></ul></li><li>Get <code>Base1</code> itable with <code>struct.get $classITable___type_20 0</code>.</li><li><code>struct.get $Base1.itable___type_13 0</code> to get the function reference of type <code>Base1.foo</code></li><li>Call <code>Derived.foo</code> with <code>call_ref</code> with <code>$0_b</code> first on the stack as receiver</li><li>Omit <code>Derived.bar</code> as it is the same.</li></ul><h3 id=varargs>varargs
<a class=anchor href=#varargs>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>sum</span>(<span style=color:#66d9ef>vararg</span> xs: Int): Int = xs.sum()
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>box</span>() {
</span></span><span style=display:flex><span>    sum(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Maybe in the process of lowering to KotlinIR, varargs are converted to Arrays.</p><pre tabindex=0><code class=language-wasm data-lang=wasm>(type $____type_54 (func (param (ref null $kotlin.IntArray___type_31)) (result i32)))
(func $sum___fun_65 (type $____type_54)
    (param $0_xs (ref null $kotlin.IntArray___type_31)) (result i32)
    local.get $0_xs  ;; type: kotlin.IntArray
    call $kotlin.collections.sum___fun_6
    return)
</code></pre><p>Definition of IntArray</p><pre tabindex=0><code class=language-wasm data-lang=wasm>(type $kotlin.wasm.internal.WasmIntArray___type_15 (array (mut i32)))
(type $kotlin.IntArray___type_31 (sub $kotlin.Any___type_13 (struct
    (field (ref $kotlin.IntArray.vtable___type_21))
    (field (ref null struct))
    (field (mut i32))
    (field (mut i32))
    (field (mut (ref null $kotlin.wasm.internal.WasmIntArray___type_15))))))
</code></pre><p>caller side</p><pre tabindex=0><code class=language-wasm data-lang=wasm>(func $box___fun_66 (type $____type_3)
    
    ;; Any parameters
    global.get $kotlin.IntArray.vtable___g_12
    ref.null struct
    i32.const 96
    i32.const 0
    
    i32.const 0
    i32.const 2
    array.new_data $kotlin.wasm.internal.WasmIntArray___type_15 1
    struct.new $kotlin.IntArray___type_31
    call $sum___fun_65
    drop)

;; dataidx = 1
(data &#34;\01\00\00\00\02\00\00\00&#34;)
</code></pre><ul><li><code>array.new_data $t $d: [i32, i32] -> [(ref $t)]</code><ul><li><code>array.new_data $kotlin.wasm.internal.WasmIntArray___type_15 1</code> creates an array with RTT <code>$kotlin.wasm.internal.WasmIntArray___type_15</code> from the first data in data section from the first data in the data section.</li><li>operand is the offset and size in data.</li><li>The <code>i32.const 0</code> and <code>i32.const 2</code> are offset and size respectively.</li></ul></li><li>The operands <code>i32.const 96</code> <code>i32.const 0</code> from <code>global.get</code> are the arguments of <code>struct.new $kotlin.IntArray___type_31</code>.</li></ul><h3 id=generic-function>generic function
<a class=anchor href=#generic-function>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>fun</span> &lt;<span style=color:#a6e22e>T</span>&gt; <span style=color:#a6e22e>id</span>(x: T): T = x
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>box</span>() {
</span></span><span style=display:flex><span>    id(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><pre tabindex=0><code class=language-wasm data-lang=wasm>(func $box___fun_63 (type $____type_3)
    
    ;; vtable, itable, typeinfo, hashcode given to kotlin.Int___type_40
    ;; Any parameters
    global.get $kotlin.Int.vtable___g_13
    global.get $kotlin.Int.classITable___g_26
    i32.const 480
    i32.const 0
    
    i32.const 1
    struct.new $kotlin.Int___type_40  ;; box
    call $id___fun_62
    ref.cast $kotlin.Int___type_40
    struct.get $kotlin.Int___type_40 4  ;; name: value, type: kotlin.Int
    drop)

(func $id___fun_62 (type $____type_56)
    (param $0_x (ref null $kotlin.Any___type_13)) (result (ref null $kotlin.Any___type_13))
    local.get $0_x  ;; type: T of &lt;root&gt;.id
    return)

(type $____type_56 (func (param (ref null $kotlin.Any___type_13)) (result (ref null $kotlin.Any___type_13))))
</code></pre><ul><li>Boxing to <code>kotlin.Int</code> instead of <code>i32</code></li><li><code>T</code> is the top type (here Any) satisfying the type constraints within kotlin types</li><li>caller casts the result to the desired type</li></ul><h3 id=generic-class>generic class
<a class=anchor href=#generic-class>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Box</span>&lt;T&gt;(t: T) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> value = t
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>box</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> b = Box&lt;Int&gt;(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    b.<span style=color:#66d9ef>value</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The type definition of <code>Box</code> is. <code>Any</code> instead of <code>T</code>.</p><pre tabindex=0><code class=language-wasm data-lang=wasm>(type $Box___type_38 (sub $kotlin.Any___type_13 (struct
    (field (ref $Box.vtable___type_27))
    (field (ref null struct))
    (field (mut i32))
    (field (mut i32))
    (field (mut (ref null $kotlin.Any___type_13)))))) ;; value
</code></pre><p>This is how the <code>Box</code> is instantiated and the fields accessed.</p><pre tabindex=0><code class=language-wasm data-lang=wasm>(func $box___fun_63 (type $____type_3)
    (local $0_b (ref null $Box___type_38))
    ref.null none
    
    ;; Any parameters
    global.get $kotlin.Int.vtable___g_13
    global.get $kotlin.Int.classITable___g_27
    i32.const 512
    i32.const 0
    
    i32.const 1
    struct.new $kotlin.Int___type_42  ;; box
    call $Box.&lt;init&gt;___fun_62
    local.tee $0_b  ;; type: &lt;root&gt;.Box&lt;kotlin.Int&gt;
    struct.get $Box___type_38 4  ;; name: value, type: T of &lt;root&gt;.Box
    ref.cast $kotlin.Int___type_42
    struct.get $kotlin.Int___type_42 4  ;; name: value, type: kotlin.Int
    drop)
</code></pre><ul><li>Nothing special to mention until <code>call $Box.&lt;init>___fun_62</code>. It&rsquo;s about boxing <code>Int</code>.</li><li>Interesting is the part corresponding to <code>b.value</code><ul><li>Get the value with <code>struct.get $Box___type_38 4</code> (type <code>kotlin.Any</code>)</li><li>Cast the result with <code>ref.cast $kotlin.Int___type_42</code></li><li>Finally, unboxing the Int.</li></ul></li></ul><h3 id=enum-and-pattern-match>enum and pattern match
<a class=anchor href=#enum-and-pattern-match>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Kind</span> { A, B }
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>box</span>() {
</span></span><span style=display:flex><span>    bar(<span style=color:#a6e22e>Kind</span>.A)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>bar</span>(k: Kind) =
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>when</span>(k) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Kind</span>.A <span style=color:#f92672>-&gt;</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Kind</span>.B <span style=color:#f92672>-&gt;</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><pre tabindex=0><code class=language-wasm data-lang=wasm>(type $Kind___type_44 (sub $kotlin.Enum___type_32 (struct
    (field (ref $Kind.vtable___type_41)) ;; vtable
    (field (ref null struct)) ;; itable
    (field (mut i32)) ;; typeInfo
    (field (mut i32)) ;; hashCode
    (field (mut (ref null $kotlin.String___type_34))) ;; enum string representation
    (field (mut i32))))) ;; ordinal
</code></pre><p>Looking at the box function, the wasm expression for <code>Kind.A</code> is a call to something called <code>$Kind_A_getInstance___fun_80</code>.</p><pre tabindex=0><code class=language-wasm data-lang=wasm>(func $box___fun_78 (type $____type_3)
    call $Kind_A_getInstance___fun_80
    call $bar___fun_79
    drop)
</code></pre><p>This is a function that calls the function <code>$Kind_initEntries___fun_76</code> and then returns an instance of <code>Kind.A</code> defined as global</p><pre tabindex=0><code class=language-wasm data-lang=wasm>(func $Kind_A_getInstance___fun_80 (type $____type_103) (result (ref null $Kind___type_44))
    call $Kind_initEntries___fun_76
    global.get $Kind_A_instance___g_8  ;; type: &lt;root&gt;.Kind?
    return)
</code></pre><p><code>$Kind_initEntries___fun_76</code>, as the name implies, creates instances of <code>Kind.A</code> and <code>Kind.B</code> and <code>global.set</code>.</p><pre tabindex=0><code class=language-wasm data-lang=wasm>(func $Kind_initEntries___fun_76 (type $____type_3)
    ;; Initialisation checks to avoid multiple runs (omitted).
    ;; ...
    ref.null none
    
    ;; const string: &#34;A&#34;
    i32.const 29
    i32.const 1128
    i32.const 1
    call $kotlin.stringLiteral___fun_25
    
    i32.const 0 ;; A -&gt; 0, B -&gt; 1
    call $Kind.&lt;init&gt;___fun_77
    global.set $Kind_A_instance___g_8  ;; type: &lt;root&gt;.Kind?

    ;; Same for Kind.B
)
</code></pre><p><code>$Kind.&lt;init>___fun_77</code> is an object initialisation function similar to the ones we have seen so far.</p><p>Now we will look at the pattern matching part.</p><pre tabindex=0><code class=language-wasm data-lang=wasm>(func $bar___fun_79 (type $____type_102)
    (param $0_k (ref null $Kind___type_44)) (result i32)
    (local $1_tmp0_subject (ref null $Kind___type_44))
    local.get $0_k  ;; type: &lt;root&gt;.Kind
    local.tee $1_tmp0_subject  ;; type: &lt;root&gt;.Kind
    call $Kind_A_getInstance___fun_80
    local.get $1_tmp0_subject  ;; type: &lt;root&gt;.Kind
    
    ;; virtual call: kotlin.Any.equals
    struct.get $kotlin.Any___type_13 0
    struct.get $kotlin.Any.vtable___type_12 0
    call_ref (type $____type_62)
    
    if (result i32)
        i32.const 1
    else
        local.get $1_tmp0_subject  ;; type: &lt;root&gt;.Kind
        call $Kind_B_getInstance___fun_81
        local.get $1_tmp0_subject  ;; type: &lt;root&gt;.Kind
        
        ;; virtual call: kotlin.Any.equals
        struct.get $kotlin.Any___type_13 0
        struct.get $kotlin.Any.vtable___type_12 0
        call_ref (type $____type_62)
        
        if (result i32)
            i32.const 2
        else
            call $kotlin.wasm.internal.throwNoBranchMatchedException___fun_30
            unreachable
        end
    end
    return)
</code></pre><p>It&rsquo;s long winded, but you can see that it is converted into an if-else like this.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>if</span> (k <span style=color:#f92672>==</span> <span style=color:#a6e22e>Kind</span>.A) { <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>; }
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (k <span style=color:#f92672>==</span> <span style=color:#a6e22e>Kind</span>.B) { <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>2</span>; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> { <span style=color:#66d9ef>throw</span> NoBranchMatchedException(<span style=color:#f92672>..</span>.) }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Enum lowering is done around [here](<a href=https://github.com/JetBrains/kotlin/blob/a441a82357270f793dac3a378505c6c6993c44be/compiler/ir/backend.wasm/>https://github.com/JetBrains/kotlin/blob/a441a82357270f793dac3a378505c6c6993c44be/compiler/ir/backend.wasm/</a> src/org/jetbrains/kotlin/backend/wasm/WasmLoweringPhases.kt#L204-L267)</p><h2 id=conculusion>Conculusion
<a class=anchor href=#conculusion>#</a></h2><ul><li>In Wasm generated by Rust(and C/C++), it was difficult to read the generated Wasm code because the allocation on linear memory and the pointer to those structures (<code>i32</code>) had no type.<ul><li>In WasmGC, the engine takes care of the allocation by just <code>struct.new</code>, so the WASM code is much easier to read.</li></ul></li><li>From the compiler&rsquo;s point of view, the target language has become high-level, and implementation might be a bit easier (engine implementation seems to have become harder though).</li><li>This time I observed only the ones that seem to be related to WasmGC, but I would like to investigate Wasm expressions in other high-level-constructs.<ul><li>Exception handling</li><li>coroutine</li><li>threading</li><li>Optimised representation of string</li><li>unsigned xxx</li></ul></li></ul><h2 id=references>References
<a class=anchor href=#references>#</a></h2><ul><li><a href="https://www.youtube.com/watch?v=LCtMC_IVCKo">Introducing Kotlin/Wasm by Zalim Bashorov & Sébastien Deleuze @ Wasm I/O 2023 - YouTube</a><ul><li>blog ver: <a href=https://seb.deleuze.fr/introducing-kotlin-wasm/>Introducing Kotlin/Wasm · seb.deleuze.fr</a></li></ul></li><li><a href=https://kotlinlang.org/docs/home.html>Kotlin Docs | Kotlin Documentation</a></li><li><a href=https://slack-chats.kotlinlang.org/c/webassembly>kotlinlang #webassembly</a></li><li><a href=https://lukasatkinson.de/2018/interface-dispatch/>Interface Dispatch | Lukas Atkinson</a></li><li><a href=https://fitzgeraldnick.com/2018/04/26/how-does-dynamic-dispatch-work-in-wasm.html>How does dynamic dispatch work in WebAssembly?</a><ul><li>How to implement dynamic dispatch in Rust. This one is implemented using <code>call_indirect</code>, but WasmGC introduces both struct and <code>typed function reference</code>, so it may be easier to use vtable or itable for each class(?).</li></ul></li></ul><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>You can find Kotlin compiler options related to Wasm <a href=https://github.com/JetBrains/kotlin/blob/8a863e00ba148f47d11c825faffd92c494e52ba6/compiler/cli/cli-common/src/org/jetbrains/kotlin/cli/common/arguments/K2JSCompilerArguments.kt#L594-L651>here</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>see <a href=https://lukasatkinson.de/2016/dynamic-vs-static-dispatch/>https://lukasatkinson.de/2016/dynamic-vs-static-dispatch/</a> and <a href=https://lukasatkinson.de/2018/interface-dispatch/>https://lukasatkinson.de/2018/interface-dispatch/</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#generating-wat-from-kotlinwasm>Generating WAT from Kotlin/Wasm</a></li><li><a href=#examining-the-wat-generated-by-kotlinwasm>Examining the WAT Generated by Kotlin/Wasm</a><ul><li><a href=#direct-function-calling>Direct Function Calling</a></li><li><a href=#data-class>(data) class</a></li><li><a href=#virtual-call>virtual call</a></li><li><a href=#interface-dispatch>interface dispatch</a></li><li><a href=#varargs>varargs</a></li><li><a href=#generic-function>generic function</a></li><li><a href=#generic-class>generic class</a></li><li><a href=#enum-and-pattern-match>enum and pattern match</a></li></ul></li><li><a href=#conculusion>Conculusion</a></li><li><a href=#references>References</a></li></ul></nav></div></aside></main></body></html>