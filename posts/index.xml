<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Rikito Taniguchi</title><link>https://tanishiking.github.io/posts/</link><description>Recent content in Posts on Rikito Taniguchi</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 21 Dec 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://tanishiking.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Exploring WAT Files Generated from Kotlin/Wasm</title><link>https://tanishiking.github.io/posts/kotlin-wasm-deep-dive/</link><pubDate>Thu, 21 Dec 2023 00:00:00 +0000</pubDate><guid>https://tanishiking.github.io/posts/kotlin-wasm-deep-dive/</guid><description>In this article, I&amp;rsquo;m examining the generated WAT (WebAssembly Text) files from Kotlin/Wasm and investigating how high-level constructs in Kotlin map to WasmGC.
Generating WAT from Kotlin/Wasm https://github.com/Kotlin/kotlin-wasm-examples
I&amp;rsquo;ll work with the kotlin-wasm-example/nodejs-example and inspecting the output. The version at the time of writing is Kotlin 1.9.20.
To generate WAT files, I&amp;rsquo;m passing the -Xwasm-generate-wat flag to the compiler1.
‚ùØ git diff nodejs-example/build.gradle.kts diff --git a/nodejs-example/build.gradle.kts b/nodejs-example/build.gradle.kts index 6b48777..fa21751 100644 --- a/nodejs-example/build.</description></item><item><title>IME event handling in JavaScript cross-browser (2017)</title><link>https://tanishiking.github.io/posts/ime-event-handling/</link><pubDate>Tue, 12 Dec 2017 00:00:00 +0000</pubDate><guid>https://tanishiking.github.io/posts/ime-event-handling/</guid><description>In 2017, when CompositionEvent is supported by many major browsers, I thought it would be easy to implement a small input completion function that supports Japanese input in JavaScript. However, the details of the implementation differed depending on the browser, and I had to do a little workaround.
Test environment Windows 10 / Microsoft Edge 41.16299.150 Windows10 / InternetExplorer11 version: 11.64.16299.0 macOS Sierra 10.12.6 / Google Chrome version: 63.0.3239.84 macOS Sierra 10.</description></item><item><title>Count unicode characters in JavaScript</title><link>https://tanishiking.github.io/posts/count-unicode-codepoint/</link><pubDate>Mon, 29 May 2017 00:00:00 +0000</pubDate><guid>https://tanishiking.github.io/posts/count-unicode-codepoint/</guid><description>There are several ways to count strings in JS in Unicode Code Point units instead of 16-bit units, but in the end, I wonder which method works in most environments (including legacy browsers like IE11) as of May 2017. I&amp;rsquo;ve done some research, and I&amp;rsquo;ll summarize it for you.
Unicode Code Points In Unicode, all characters are assigned an ID (code point) (0 to 0x10FFFF). The code point is written as U+hexdecimal.</description></item></channel></rss>