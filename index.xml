<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Rikito Taniguchi</title><link>https://tanishiking.github.io/</link><description>Recent content on Rikito Taniguchi</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 01 Jan 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://tanishiking.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>New types and instructions to be introduced in WasmGC</title><link>https://tanishiking.github.io/posts/wasm-gc/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://tanishiking.github.io/posts/wasm-gc/</guid><description>In November 2023, the WasmGC1 became the default in Chrome2 and Firefox3. It is a really exciting change, and is a good sign that the WasmGC is coming to standarization. Some GC programming languages such as OCaml4, Kotlin5, Dart6, and Java7 have an implementation that compiles to Wasm with WasmGC support.
We can learn the high-level view of WasmGC in the blog post by V8: A new way to bring garbage collected programming languages efficiently to WebAssembly · V8</description></item><item><title>Exploring WAT Files Generated from Kotlin/Wasm</title><link>https://tanishiking.github.io/posts/kotlin-wasm-deep-dive/</link><pubDate>Thu, 21 Dec 2023 00:00:00 +0000</pubDate><guid>https://tanishiking.github.io/posts/kotlin-wasm-deep-dive/</guid><description>In this article, I&amp;rsquo;m examining the generated WAT (WebAssembly Text) files from Kotlin/Wasm and investigating how high-level constructs in Kotlin map to WasmGC.
Generating WAT from Kotlin/Wasm # https://github.com/Kotlin/kotlin-wasm-examples
I&amp;rsquo;ll work with the kotlin-wasm-example/nodejs-example and inspecting the output. The version at the time of writing is Kotlin 1.9.20.
To generate WAT files, I&amp;rsquo;m passing the -Xwasm-generate-wat flag to the compiler1.
❯ git diff nodejs-example/build.gradle.kts diff --git a/nodejs-example/build.gradle.kts b/nodejs-example/build.gradle.kts index 6b48777..fa21751 100644 --- a/nodejs-example/build.</description></item><item><title>How to build a simple Scala application with Bazel</title><link>https://tanishiking.github.io/posts/bazel-scala/</link><pubDate>Wed, 15 Feb 2023 00:00:00 +0000</pubDate><guid>https://tanishiking.github.io/posts/bazel-scala/</guid><description>Wrote on How to build a simple Scala application with Bazel - VirtusLab.</description></item><item><title>IME event handling in JavaScript cross-browser (2017)</title><link>https://tanishiking.github.io/posts/ime-event-handling/</link><pubDate>Tue, 12 Dec 2017 00:00:00 +0000</pubDate><guid>https://tanishiking.github.io/posts/ime-event-handling/</guid><description>In 2017, when CompositionEvent is supported by many major browsers, I thought it would be easy to implement a small input completion function that supports Japanese input in JavaScript. However, the details of the implementation differed depending on the browser, and I had to do a little workaround.
Test environment # Windows 10 / Microsoft Edge 41.16299.150 Windows10 / InternetExplorer11 version: 11.64.16299.0 macOS Sierra 10.12.6 / Google Chrome version: 63.0.3239.84 macOS Sierra 10.</description></item><item><title>Count unicode characters in JavaScript</title><link>https://tanishiking.github.io/posts/count-unicode-codepoint/</link><pubDate>Mon, 29 May 2017 00:00:00 +0000</pubDate><guid>https://tanishiking.github.io/posts/count-unicode-codepoint/</guid><description>There are several ways to count strings in JS in Unicode Code Point units instead of 16-bit units, but in the end, I wonder which method works in most environments (including legacy browsers like IE11) as of May 2017. I&amp;rsquo;ve done some research, and I&amp;rsquo;ll summarize it for you.
Unicode Code Points # In Unicode, all characters are assigned an ID (code point) (0 to 0x10FFFF). The code point is written as U+hexdecimal.</description></item></channel></rss>